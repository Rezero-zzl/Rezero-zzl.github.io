# [题目描述](https://leetcode.cn/problems/implement-rand10-using-rand7/description/?orderBy=most_votes)
现有一个函数`rand7()`，提供均匀随机生成[1,7]中的整数功能，现在要你用`rand7()`函数实现一个`rand10()`函数，尽可能少的调用`rand7()`

# 解题思路
- 明确一个公式`(randX()-1)*Y + randY() == randXY()`，怎么理解呢，接着往下看
- `randXY()`代表能随机等概率生成[1,XY]中的任意整数的函数，我们可以将这个区间看作一个X行Y列的二维矩阵，每一行的区间跨度是Y，即第一行[1,Y]，
第二行[Y+1,Y+Y]，以此类推
- 现在我们再来看公式，加数`randY()`代表的就是二维矩阵的第一行，而被加数`(randX()-1)*Y`代表，从第一行到第i行所需要的增量，第一行不需要增量为`(1-1)*X`即0，如第二行
距第一行所需要的增量为`1*Y`,第七行距第一行所需要的增量为`(X-1)*Y`
- 因此我们将公式带入到题目，我们可以得出`rand49()`,那么我们如何通过`rand49()`求出`rand10()`呢
- 我们观察可以得出，在[1,40]的范围内，个位数总共出现了四次[0,9]的变化，通过加1，可以等概率生成[1,10]，因此我们可以通过[拒绝采样](https://zhuanlan.zhihu.com/p/379473275)，简单来说就是因为[41,49]中没有出现个位数为0的数
不满足等概率出现[0，9]，因此我们丢弃这部分数据，即当`rand49()`函数的结果小于等于40时，通过`rand49()%10+1`可以达到等概率生成[1,10]的目的
- 以上我们已经达到了等概率生成[1,10]的需求，但是当`rand49()`函数的结果在[41,49]时，我们不得不再进行下一次尝试，直到其结果落在[1,40]，此时相当于浪费了一些数据，那么如何优化呢
- 当结果落在[41,49]时，我们通过取个位，可以得到随机[1,9]的结果，即相当于`rand9()`，我们仍然可以通过公式`(rand9()-1)*7 + rand7()`
生成`rand63()`函数，通过拒绝采样和上述步骤，可以得到六组[1,10]，以及一个[1,3]的`rand3()`，此时我们将浪费从9降为了3
- 同理，通过`(rand3()-1)*7 + rand7()`生成`rand21()`然后通过上述步骤，得到两组[1,10]，浪费一个数字1
![](https://raw.githubusercontent.com/Rezero-zzl/Rezero-zzl.github.io/main/docs/assets/img/lalgorithm/1-12.jpg)
# 代码
```java
class Solution extends SolBase {
    public int rand10() {
        while(true){
            //  生成rand49
            int x_49 = (rand7()-1)*7 + rand7();
            if(x_49 <= 40){ //  拒绝采样
                return x_49%10 + 1;
            }
            //  剩余数据[41,49]数据得到rand9
            int x_9 = x_49%10;
            //  生成rand63
            int x_63 = (x_9-1)*7 + rand7();
            if(x_63 <= 60){ //  拒绝采样
                return x_63%10 + 1;
            }
            // 剩余数据61,63]得到rand3
            int x_3 = x_63%10;
            //  生成rand21
            int x_21 = (x_3 -1)*7 + rand7();
            if(x_21 <= 20){ //  拒绝采样
                return x_21%10 + 1;
            }
        }
    }
}
```

# 总结
- 关键点在于理解`(randX()-1)*Y + randY() == randXY()`这个公式的推导
- 其次，对于如何尽量少调用`rand7()`我们需要去算对应情况的数学期望
- 当然如果考虑实际调用效率的情况，我们还需要考虑循环调用次数，因为重新开始循环是需要调用[分支跳转指令](https://blog.csdn.net/oneMelon/article/details/110711392)的